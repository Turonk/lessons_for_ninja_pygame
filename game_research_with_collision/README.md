# Логика столкновения и движения врага к игроку

## Что добавлено (Шаг 1 - Столкновения):

### 1. **Функция проверки столкновения**
```python
def check_collision(rect1, rect2):
    """Проверяет столкновение между двумя прямоугольниками"""
    return rect1.colliderect(rect2)
```

### 2. **Состояние игры**
- Добавлена переменная `game_over = False`
- Игра "замирает" когда `game_over = True`

### 3. **Проверка столкновения в игровом цикле**
```python
# Проверяем столкновение между игроком и врагом
if check_collision(player.rect, enemy.rect):
    game_over = True
```

### 4. **Остановка движения при game_over**
- Игрок и враг перестают двигаться
- Но продолжают отрисовываться

### 5. **Экран окончания игры**
- Полупрозрачный черный фон
- Сообщение "ИГРА ОКОНЧЕНА!"
- Подсказка для перезапуска (R) или выхода (ESC)

### 6. **Перезапуск игры**
- Нажатие R возвращает все объекты в начальные позиции
- Сбрасывает состояние прыжка и скорости

## Как работает:

1. **Каждый кадр** проверяется пересечение прямоугольников `player.rect` и `enemy.rect`
2. **При столкновении** устанавливается `game_over = True`
3. **Движение останавливается** - объекты не обновляют позиции
4. **Показывается экран окончания** с сообщением и подсказками
5. **Перезапуск** возвращает игру в начальное состояние

## Использование в уроках:

Эта логика показывает:
- Как проверять столкновения между объектами
- Как управлять состояниями игры
- Как создавать экраны паузы/окончания
- Как реализовывать перезапуск игры

## Что добавлено (Шаг 2 - Движение врага к игроку):

### 1. **Функция спавна врага**
```python
def spawn_enemy():
    side = random.choice(["left", "right"])
    if side == "left":
        x = -ENEMY_WIDTH  # За левым краем
    else:
        x = SCREEN_WIDTH  # За правым краем
    y = GROUND_Y - ENEMY_HEIGHT
    return Enemy(x, y)
```

### 2. **Метод движения к игроку**
```python
def move_towards_player(self, player_x):
    if self.x < player_x:
        self.x += self.speed  # Двигаемся вправо к игроку
    elif self.x > player_x:
        self.x -= self.speed  # Двигаемся влево к игроку
```

### 3. **Проверка выхода за экран**
```python
def is_off_screen(self):
    return self.x < -self.width or self.x > SCREEN_WIDTH
```

### 4. **Автоматический респавн**
- Когда враг уходит за пределы экрана, создается новый
- Новый враг появляется случайно слева или справа

## Как работает движение к игроку:

1. **Враг появляется** за пределами экрана (слева или справа)
2. **Определяет позицию игрока** по оси X
3. **Двигается в направлении игрока** с постоянной скоростью
4. **При выходе за экран** уничтожается и создается новый враг
5. **Столкновение** происходит при касании с игроком

## Использование в уроках:

Эта система показывает:
- Как реализовать ИИ для преследования игрока
- Как работать с системой спавна объектов
- Как управлять жизненным циклом игровых объектов
- Как использовать случайность в играх
